<html>
    <head>
        <title>Visualization</title>
        <script src="https://d3js.org/d3.v7.min.js"></script>
    </head>
    <body>
        <!-- First Visualization: Chord Diagram -->
        <h1>Chord Graph Example</h1>
        <svg id="chord" height="850" width="850" style="background: #fff; margin-top:50px" ></svg>
        <script>
            const width = d3.select("#chord").attr("width");
            const height = d3.select("#chord").attr("height");
            const chordChart = d3.select("#chord").append("g");
            
            const drawChord = async () => {
              const colorPalette = ["#48bf8e", "#075c62", "#a1def0", "#5e2a96", 
                                    "#e775cc", "#f3c5fa", "#9a76af", "#1c4585", 
                                    "#479abc", "#94ea5b", "#1d6d1f", "#cddb9b", 
                                    "#604020", "#d48f4d", "#f24219", "#8e1023", 
                                    "#8c956d", "#2cf52b", "#ff0087", "#e9d737"]
          
              const edges_ds = await d3.json("edges.json");
              const nodes_ds = await d3.json("nodes.json");

              let links = edges_ds;
              let nodes = nodes_ds;

              console.log("links", links);
              console.log("nodes", nodes);
              
              let matrix = [];
              let connections = {}; 
              for (let i=0; i< Object.keys(nodes).length; i++) {
                  let row = [];
                  for (let j=0; j< Object.keys(nodes).length; j++) {row.push(0);}
                  matrix.push(row);
                  connections[i] = [i]; 
              }
              console.log("matrix", matrix);

              Object.values(links).forEach( d => {
                if (d.Weight > 0) {
                      matrix[d.Source][d.Target] = d.Weight;
                      matrix[d.Target][d.Source] = d.Weight;
                      connections[d.Source].push(d.Target);
                      connections[d.Target].push(d.Source);
                }
              });
              console.log("connections", connections);

              let radius = (width / 2.0) - 125;
              let chordGen = d3.chord()
                    .padAngle(.04)
                    .sortSubgroups(d3.descending)
                    .sortChords(d3.descending);

              // Thickness of container
              let arcGen = d3.arc()
                    .innerRadius(radius)
                    .outerRadius(radius + 40);
              let ribbonGen = d3.ribbon()
                      .radius(radius);
              let chords = chordGen(matrix);
              
              console.log("chords", chords);

              chordChart.attr("transform",`translate(${width/2.0},${height/2.0})`);
              let colorScale = d3.scaleOrdinal().range(colorPalette);

              // Circular Container
              let ringContainer = chordChart.append("g");
              let rings = ringContainer.selectAll("g.segment")
                            .data(chords.groups)
                            .join("g")
                            .attr("class","segment");
            
              rings.append("path")
                   .attr("fill", d => colorScale( nodes[ d.index ].SubContinent ))
                   .attr("stroke", d => colorScale( nodes[ d.index ].SubContinent ))
                   .attr("d", arcGen);

              // Ribbons
              let ribbonContainer = chordChart.append("g");
              let ribbons = ribbonContainer.selectAll("path.ribbon")
                      .data(chords)
                      .join("path")
                      .attr("class","ribbon")
                      .attr("fill-opacity", 0.5)
                      .attr("stroke", "none")
                      .attr("fill", d => colorScale( nodes[ d.source.index ].SubContinent ))
                      .attr("d", ribbonGen);

              // Label the Subcontinents
              chords.groups.forEach(d =>{
                  let transform = '';
                  // find midpoint, convert to degrees
                  let midpoint = (d.startAngle + d.endAngle) / 2;
                  let rotation = ( midpoint ) * ( 180 / Math.PI ) - 90;
                  //2PI*unit radius = 360, PI*unit = 180
                  transform = transform + ` rotate(${rotation})`;
                  transform = transform + ` translate(${radius+25}, 0)`;
                  d.anchor = 'middle'
                  if (rotation > 90) {
                      transform = transform + ' rotate(180)';
                      // Notice text anchor issue that also first
                      d.anchor = "middle";
                  }
                  d.trans = transform;
              });
              
              rings.append('text')
                   .attr('transform', d=> d.trans)
                   .text(d => nodes[d.index].SubContinent)
                   .attr('text-anchor', d => d.anchor);
                //    .attr('fill', d => colorScale( nodes[ d.index ].Continent ));
            }
            drawChord();
        </script>

        <!-- Second Visualization: Spider Diagram -->
        <h1>Spider Diagram</h1>
        <p id = 'spider-chart'>
            <svg id="spider" height="600" width="600"></svg>
            <div id="send-bar"></div>
            <div id="receive-bar"></div>
            
            <script>
            
            const features = ["health","climate","civil liberty"];
            const country_names = ['China','Japan','South Korea','North Korea','Taiwan','Mongolia',"United States",'Canada']
            
            country_data = {
            'China': {'health': 3.363636363636363, 'climate': 0.7257151269449413, 'civil liberty': 4},
            'Japan': {'health': 9.772727272727273, 'climate': 3.918873009761511, 'civil liberty': 8},
            'South Korea': {'health': 8.136363636363637, 'climate': 4.033474509093379, 'civil liberty': 8},
            'North Korea': {'health': 0.13636363636363508, 'climate': 0.0, 'civil liberty': 3}, 
            'Taiwan': {'health': 7.0, 'climate': 4.87011075125133, 'civil liberty': 9}, 
            'Mongolia': {'health': 0.0, 'climate': 0.1468756369895592, 'civil liberty': 8}, 
            'United States': {'health': 9.113636363636362, 'climate': 10.0, 'civil liberty': 9},
            'Canada': {'health': 10.0, 'climate': 8.362568794872375, 'civil liberty': 9} }
            console.log(country_data)
            
            allKeys = Object.keys(country_data);
            console.log("allkeys", allKeys);
                            
            const svg = d3.select("svg#spider");
            const spider_width = svg.attr("width");
            const spider_height = svg.attr("height");
            
            let spiderChart = svg.append("g").attr("id","diagrams");
            let annotations = svg.append("g").attr("id","annotations");
            
            let radialScale = d3.scaleLinear()
                .domain([0,10])
                .range([0,250]);
            let ticks = [2,4,6,8,10];
            
            ticks.forEach(t =>
                annotations.append("circle")
                .attr("cx", 300)
                .attr("cy", 300)
                .attr("fill", "none")
                .attr("stroke", "gray")
                .attr("r", radialScale(t))
            );
            
            function angleToCoordinate(angle, value){
                let x = Math.cos(angle) * radialScale(value);
                let y = Math.sin(angle) * radialScale(value);
                return {"x": 300 + x, "y": 300 - y};
            }
            
            for (var i = 0; i < features.length; i++) {
                console.log(i);
                let ft_name = features[i];
                let angle = (Math.PI / 2) + (2 * Math.PI * i / features.length);
                let line_coordinate = angleToCoordinate(angle, 10);
                let label_coordinate = angleToCoordinate(angle, 10.5);
                console.log(line_coordinate);
            
                //draw axis line
                annotations.append("line")
                .attr("x1", 300)
                .attr("y1", 300)
                .attr("x2", line_coordinate.x)
                .attr("y2", line_coordinate.y)
                .attr("stroke","black");
            
                //draw axis label
                annotations.append("text")
                .attr("x", label_coordinate.x)
                .attr("y", label_coordinate.y)
                .text(ft_name);
            }
            
            allKeys.forEach( d => {
            
            d3.select("div#send-bar")
              .append("button")
              .text(d)
              .on('click', function(){
                updateSend(d);
            
              })
            
            
              d3.select("div#receive-bar")
              .append("button")
              .text(d)
              .on('click', function(){
                updateReceive(d);
            
              })
            
            
            });
            
            tri_send = spiderChart.append("path")
                             .attr("stroke-width", 3)
                             .attr("stroke-opacity", 1)
                             .attr("opacity", 0.5);
            
            tri_receive = spiderChart.append("path")
                             .attr("stroke-width", 3)
                             .attr("stroke-opacity", 1)
                             .attr("opacity", 0.5);
            
            
            
            let colorScale = d3.scaleOrdinal()
                                .domain(country_names)
                                .range(["tomato", "slateblue", "navy","rosybrown","skyblue","sandybrown","plum"])
            
            
            function updateSend (countryKey) {
                const data = country_data[countryKey];
            
                    console.log("data",data)
                
            
            let line = d3.line()
                .x(d => d.x)
                .y(d => d.y);
            
            
            function getPathCoordinates(data_point){
            let coordinates = [];
                for (var i = 0; i < features.length; i++){
                    let ft_name = features[i];
                
                    let angle = (Math.PI /2) + (2 * Math.PI * i / features.length);
                    coordinates.push(angleToCoordinate(angle, data_point[ft_name]));
                }
                return coordinates;
            }
            
                let d = data;
                console.log("d",d);
                
                let color = 'gray';
                let coordinates = getPathCoordinates(d);
                console.log("coordinates", coordinates);
                
                //draw the path element
                tri_send.datum(coordinates)  
                    .transition()
                    .attr("d", line) 
                    .attr("stroke", d => colorScale(d))
                    .attr("fill", d => colorScale(d))            
            }
            
            function updateReceive (countryKey) {
                const data = country_data[countryKey];
            
                    console.log("data",data)
        
            let line = d3.line()
                .x(d => d.x)
                .y(d => d.y);
            
            function getPathCoordinates(data_point){
            let coordinates = [];
                for (var i = 0; i < features.length; i++){
                    let ft_name = features[i];
                
                    let angle = (Math.PI /2) + (2 * Math.PI * i / features.length);
                    coordinates.push(angleToCoordinate(angle, data_point[ft_name]));
                }
                return coordinates;
            }
            
                let d = data;
                console.log("d",d);
                
                let color = 'gray';
                let coordinates = getPathCoordinates(d);
                console.log("coordinates", coordinates);
                
            
            
                //draw the path element
                tri_receive.datum(coordinates)  
                    .transition()
                    .attr("d", line) 
                    .attr("stroke", d => colorScale(d))
                    .attr("fill", d => colorScale(d))            
              
            
            }
            </script>
        </p>
    </body>
</html>