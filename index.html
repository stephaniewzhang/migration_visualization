<html>
    <head>
        <title>Visualization</title>

        <link rel="stylesheet" type="text/css" href="../css/styles.css">
        <script src="https://d3js.org/d3.v7.min.js"></script>
    </head>
    <body>
        <!-- First Visualization: Chord Diagram -->
        <!--<h1>Chord Graph Example</h1> -->
        <svg id="chord" height="800" width="800" ></svg>
        <script>
            const width = d3.select("#chord").attr("width");
            const height = d3.select("#chord").attr("height");
            const chordChart = d3.select("#chord").append("g");
            
            const drawChord = async () => {
              const colorPalette = ["#48bf8e", "#075c62", "#a1def0", "#5e2a96", 
                                    "#e775cc", "#f3c5fa", "#9a76af", "#1c4585", 
                                    "#479abc", "#94ea5b", "#1d6d1f", "#cddb9b", 
                                    "#604020", "#d48f4d", "#f24219", "#8e1023", 
                                    "#8c956d", "#2cf52b", "#ff0087", "#e9d737"]
          
              const edges_ds = await d3.json("edges.json");
              const nodes_ds = await d3.json("nodes.json");

              let links = edges_ds;
              let nodes = nodes_ds;

              console.log("links", links);
              console.log("nodes", nodes);
              
              let matrix = [];
              let connections = {}; 
              for (let i=0; i< Object.keys(nodes).length; i++) {
                  let row = [];
                  for (let j=0; j< Object.keys(nodes).length; j++) {row.push(0);}
                  matrix.push(row);
                  connections[i] = [i]; 
              }
              console.log("matrix", matrix);

              Object.values(links).forEach( d => {
                if (d.Weight > 0) {
                      matrix[d.Source][d.Target] = d.Weight;
                      matrix[d.Target][d.Source] = d.Weight;
                      connections[d.Source].push(d.Target);
                      connections[d.Target].push(d.Source);
                }
              });
              console.log("connections", connections);

              let radius = (width / 2.0) - 125;
              let chordGen = d3.chord()
                    .padAngle(.04)
                    .sortSubgroups(d3.descending)
                    .sortChords(d3.descending);

              // Thickness of container
              let arcGen = d3.arc()
                    .innerRadius(radius)
                    .outerRadius(radius + 40);
              let ribbonGen = d3.ribbon()
                      .radius(radius);
              let chords = chordGen(matrix);
              
              console.log("chords", chords);

              chordChart.attr("transform",`translate(${width/2.0},${height/2.0})`);
              let colorScale = d3.scaleOrdinal().range(colorPalette);

              // Circular Container
              let ringContainer = chordChart.append("g");
              let rings = ringContainer.selectAll("g.segment")
                            .data(chords.groups)
                            .join("g")
                            .attr("class","segment");
            
              rings.append("path")
                   .attr("fill", d => colorScale( nodes[ d.index ].SubContinent ))
                   .attr("stroke", d => colorScale( nodes[ d.index ].SubContinent ))
                   .attr("d", arcGen);

              // Ribbons
              let ribbonContainer = chordChart.append("g");
              let ribbons = ribbonContainer.selectAll("path.ribbon")
                      .data(chords)
                      .join("path")
                      .attr("class","ribbon")
                      .attr("fill-opacity", 0.5)
                      .attr("stroke", "none")
                      .attr("fill", d => colorScale( nodes[ d.source.index ].SubContinent ))
                      .attr("d", ribbonGen);

              // Label the Subcontinents
              chords.groups.forEach(d =>{
                  let transform = '';
                  // find midpoint, convert to degrees
                  let midpoint = (d.startAngle + d.endAngle) / 2;
                  let rotation = ( midpoint ) * ( 180 / Math.PI ) - 90;
                  //2PI*unit radius = 360, PI*unit = 180
                  transform = transform + ` rotate(${rotation})`;
                  transform = transform + ` translate(${radius+25}, 0)`;
                  d.anchor = 'middle'
                  if (rotation > 90) {
                      transform = transform + ' rotate(180)';
                      // Notice text anchor issue that also first
                      d.anchor = "middle";
                  }
                  d.trans = transform;
              });
              
              rings.append('text')
                   .attr('transform', d=> d.trans)
                   .text(d => nodes[d.index].SubContinent)
                   .attr('text-anchor', d => d.anchor);
                //    .attr('fill', d => colorScale( nodes[ d.index ].Continent ));
            }
            drawChord();
        </script>

        <!-- Second Visualization: Spider Diagram -->
       <!---<h1>Spider Diagram</h1> -->
        <p id = 'spider-chart'>

            <div id="send-bar">
                <h3>Sending country:</h3>
            </div>
            <div id="receive-bar">
                <h3>Receiving country:</h3>
            </div>

            <svg id="spider" height="650" width="650"></svg>

            
            <script>
            
            const features = ["Health","CO2 Emission","Civil Liberty"];
            const country_names = ['China','Japan','South Korea','North Korea','Taiwan','Mongolia',"United States",'Canada']
            const country_colors = ['#5E1240','#134C5B','#E16425','#033148','#0D6D76','#C88477','#E6484B','#AAD9D1']


            let spider_colorScale = d3.scaleOrdinal()
                                .domain([country_names])
                                .range(country_colors);


            
            country_data = {
            'China': {'Health': 6.2, 'CO2 Emission': 0.7257151269449413, 'Civil Liberty': 4},
            'Japan': {'Health': 9.02, 'CO2 Emission': 3.918873009761511, 'Civil Liberty': 8},
            'South Korea': {'Health': 8.3, 'CO2 Emission': 4.033474509093379, 'Civil Liberty': 8},
            'North Korea': {'Health': 4.78, 'CO2 Emission': 0.0, 'Civil Liberty': 3}, 
            'Taiwan': {'Health': 7.8, 'CO2 Emission': 4.87011075125133, 'Civil Liberty': 9}, 
            'Mongolia': {'Health': 4.72, 'CO2 Emission': 0.1468756369895592, 'Civil Liberty': 8}, 
            'United States': {'Health': 8.73, 'CO2 Emission': 10.0, 'Civil Liberty': 9},
            'Canada': {'Health': 9.12, 'CO2 Emission': 8.362568794872375, 'Civil Liberty': 9} }
            console.log(country_data)
            
            allKeys = Object.keys(country_data);
            console.log("allkeys", allKeys);
                            
            const svg = d3.select("svg#spider");
            const spider_width = svg.attr("width");
            const spider_height = svg.attr("height");
            
            let spiderChart = svg.append("g").attr("id","diagrams");
            let annotations = svg.append("g").attr("id","annotations");
            
            let radialScale = d3.scaleLinear()
                .domain([0,5])
                .range([0,125]);
            let ticks = [2,4,6,8,10];
            
            ticks.forEach(t =>
                annotations.append("circle")
                .attr("cx", 300)
                .attr("cy", 300)
                .attr("fill", "none")
                .attr("stroke", "lightgray")
                .attr("r", radialScale(t))
            );
            
            function angleToCoordinate(angle, value){
                let x = Math.cos(angle) * radialScale(value);
                let y = Math.sin(angle) * radialScale(value);
                return {"x": 300 + x, "y": 300 - y};
            }
            
            for (var i = 0; i < features.length; i++) {
                console.log(i);
                let ft_name = features[i];
                let angle = (Math.PI / 2) + (2 * Math.PI * i / features.length);
                let line_coordinate = angleToCoordinate(angle, 10);
                let label_coordinate = angleToCoordinate(angle, 10.5);
                console.log(line_coordinate);
            
                //draw axis line
                annotations.append("line")
                .attr("x1", 300)
                .attr("y1", 300)
                .attr("x2", line_coordinate.x)
                .attr("y2", line_coordinate.y)
                .attr("stroke","lightgray");
            
                //draw axis label
                annotations.append("text")
                .attr("x", label_coordinate.x)
                .attr("y", label_coordinate.y)
                .text(ft_name)
                .attr("stroke","gray")
                .attr("fill","gray");

            }
            
            allKeys.forEach( d => {
            
            d3.select("div#send-bar")
              .append("button")
              .text(d)
              .style ("display" , "inline-block")
              .style("margin","4")
              //.style ('text-decoration',"none")
             // .style ("background-color",spider_colorScale(d) )
            //   .style("stroke-width",10)
            //   .style ("border-color", "white")
            //   .attr ("opacity" , 0.5)
            //   .style ("color" ,"white")
              .on('click', function(){
                updateSend(d); 
            
              }) 
            
            
              d3.select("div#receive-bar")
              .append("button")
              .text(d)
              .style("margin","4")
              .on('click', function(){
                updateReceive(d);
            
              })
            
            
            });
            
            tri_send = spiderChart.append("path")
                             .attr("stroke-width", 3)
                             .attr("stroke-opacity", 1)
                             .attr("opacity", 0.7);
            
            tri_receive = spiderChart.append("path")
                             .attr("stroke-width", 3)
                             .attr("stroke-opacity", 1)
                             .attr("opacity", 0.7);
            
            
            


            console.log("spider_colorScale", spider_colorScale);            
            
            
            function updateSend (countryKey) {
                const data = country_data[countryKey];
            
                    console.log("data",data)
                
            
            let line = d3.line()
                .x(d => d.x)
                .y(d => d.y);
            
            
            function getPathCoordinates(data_point){
            let coordinates = [];
                for (var i = 0; i < features.length; i++){
                    let ft_name = features[i];
                
                    let angle = (Math.PI /2) + (2 * Math.PI * i / features.length);
                    coordinates.push(angleToCoordinate(angle, data_point[ft_name]));
                }
                return coordinates;
            }
            
                let d = data;
                console.log("d",d);
                
                
                let coordinates = getPathCoordinates(d);
                console.log("coordinates", coordinates);
                
                //draw the path element
                tri_send.datum(coordinates)  
                    .transition()
                    .attr("d", line) 
                    .attr("stroke", spider_colorScale(countryKey))
                    .attr("fill", spider_colorScale(countryKey))            
            }





            
            function updateReceive (countryKey) {
                const data = country_data[countryKey];
            
                    console.log("data",data)
        
            let line = d3.line()
                .x(d => d.x)
                .y(d => d.y);
            
            function getPathCoordinates(data_point){
            let coordinates = [];
                for (var i = 0; i < features.length; i++){
                    let ft_name = features[i];
                
                    let angle = (Math.PI /2) + (2 * Math.PI * i / features.length);
                    coordinates.push(angleToCoordinate(angle, data_point[ft_name]));
                }
                return coordinates;
            }
            
                let d = data;
                console.log("d",d);
                
                
                let coordinates = getPathCoordinates(d);
                console.log("coordinates", coordinates);
                
            
            
                //draw the path element
                tri_receive.datum(coordinates)  
                    .transition()
                    .attr("d", line) 
                    .attr("stroke", spider_colorScale(countryKey))
                    .attr("fill", spider_colorScale(countryKey))            
              
            
            }
            </script>
        </p>
    </body>
</html>